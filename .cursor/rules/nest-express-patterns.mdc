---
description: NestJS + Express middleware, guards, and API patterns
globs: "backend/**/*.ts"
alwaysApply: false
---
# NestJS + Express Patterns

## Middleware & Security
- Always register `helmet()` in `main.ts` before any routes.
- Enable CORS with explicit `origin` whitelist; never use `origin: '*'` in production.
- Use `@nestjs/throttler` globally; override per-route with `@Throttle()`.
- Register `ValidationPipe` globally with `whitelist: true` and `forbidNonWhitelisted: true`.

## Guards & Interceptors
- Use `@UseGuards(JwtAuthGuard)` on protected controllers, not individual routes.
- Create a `RolesGuard` + `@Roles()` decorator for RBAC.
- Use interceptors for response shaping (e.g., wrapping in `{ data, meta }`).

## Controllers
- Keep controllers thin: validate input, call service, return result.
- Use `@ApiTags()` and `@ApiOperation()` from Swagger on every endpoint.
- Return proper HTTP codes: 201 for create, 204 for delete, 200 for read/update.

## Services
- One service per domain entity. Inject repositories, not raw DB clients.
- Throw NestJS built-in exceptions (`NotFoundException`, `ConflictException`).
- Never catch errors silently; let the global exception filter handle them.

## DTOs
- One DTO per operation: `CreateCourseDto`, `UpdateCourseDto`, `CourseResponseDto`.
- Use `class-validator` decorators: `@IsEmail()`, `@IsString()`, `@MinLength()`.
- Use `@Exclude()` from `class-transformer` to hide sensitive fields in responses.

## Example
```typescript
// BAD: logic in controller, no validation
@Post()
create(@Body() body: any) {
  return this.db.query(`INSERT INTO ...`);
}

// GOOD: validated DTO, service layer, proper response
@Post()
@HttpCode(HttpStatus.CREATED)
create(@Body() dto: CreateCourseDto): Promise<CourseResponseDto> {
  return this.coursesService.create(dto);
}
```
